package com.sho.renaissance.batch.util;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.jms.JMSException;
import javax.jms.TextMessage;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.codehaus.jettison.json.JSONException;
import org.codehaus.jettison.json.JSONObject;
import org.springframework.web.client.RestTemplate;

import com.capgemini.cif.core.domain.BatchItemProcessMessage;
import com.capgemini.cif.core.domain.Parameter;
import com.sho.renaissance.batch.constants.BatchConstants;

/**
 * This class is utilty class for Batch
 * 
 * @author gdhimate
 *
 */
public class CommonUtils {
	
	private static Log logger = LogFactory.getLog(CommonUtils.class);
	static RestTemplate restTemplate = new RestTemplate();
	
	private static final String REGEX_NUMERIC_PATTER="\\d+";
	
	/**
	 * @param property
	 * @return
	 * 
	 * 		Load properties from properties file
	 */
	public static String getPropertyFromClassPath(String propertyFile,String property) {

		Properties properties = new Properties();
		InputStream inputStream = null;
		try {
			inputStream = CommonUtils.class.getClassLoader().getResourceAsStream(propertyFile);

			if (inputStream == null) {
				logger.error("Unable to load property file " + propertyFile);
				return null;
			}
			properties.load(inputStream);

			if (!properties.containsKey(property)) {
				logger.error("Unable to find the require property " + property + " from file " + propertyFile);
				return null;
			}

			return properties.getProperty(property);
		} catch (IOException e) {
			logger.error("Unable to get property ");
		} finally {
			if (inputStream != null) {
				try {
					inputStream.close();
				} catch (IOException e) {
					logger.error("Unable to close inputStream ");
				}
			}
		}

		return null;

	}
	
	/**
	 * This method is used for REST call on POST
	 * 
	 * @param uri
	 * @param object
	 * @return
	 */
	public static Object postJSONForObject(String uri,Object object){
		logger.debug("POST Rest call to uri "+uri);
		return restTemplate.postForObject(uri,object, object.getClass());
		
	}
	
	/**
	 * Returns the
	 * 
	 * @param messages
	 * @return
	 */
	public static String getErrorMessage(List<BatchItemProcessMessage> messages) {
		StringBuilder messageResult = new StringBuilder();

		if(messages.isEmpty()){
			return null;
		}
		for (int i = 0; i < messages.size(); i++) {
			messageResult.append(messages.get(i).getMessage());
			messageResult.append(",");
		}
		messageResult.append(messages.get(messages.size()-1).getMessage());

		return messageResult.toString();

	}
	
	public static String[] getPredecessors(String objectId, String processId, String sourceSysId){
		String serviceUrl = CommonUtils.getPropertyFromClassPath(BatchConstants.APPLICATION_PROPERTY_FILE,
				BatchConstants.CIF_PARAMETER_HOSTNAME)
				+ CommonUtils.getPropertyFromClassPath(BatchConstants.APPLICATION_PROPERTY_FILE,
						BatchConstants.CIF_PARAMETER_URI);

		Parameter parameter = new Parameter();
		parameter.setObjectId(objectId);
		parameter.setProcessId(processId);
		parameter.setSrcSysId(sourceSysId);

		Parameter responseParameter = new Parameter();

		responseParameter = (Parameter) CommonUtils.postJSONForObject(serviceUrl, parameter);

		String[] predecessors = null;
		if (null != responseParameter.getValue()) {
			if (responseParameter.getValue().toString().length() == 0) {
				return null;
			}
			predecessors = responseParameter.getValue().toString().split(",");

		}
		
		return predecessors;
	}
	
	/**
	 * Gets the Interface Number from Interface friendly name
	 * @param property
	 * @return
	 */
	public static String getInterfaceId(String friendlyName) {
		
		Pattern pattern = Pattern.compile(REGEX_NUMERIC_PATTER);
		Matcher matcher = pattern
				.matcher(friendlyName);
		matcher.find();

		return matcher.group();
	}
	
	/**
	 * @param textMessage
	 * @return The fileName from json object generated by Amazon AWS
	 * @throws JMSException
	 * @throws JSONException
	 */
	public static String getFileNameFromTopicMessage(TextMessage textMessage) throws JMSException, JSONException {

		String text = textMessage.getText();
		JSONObject jsonObj = new JSONObject(text);

		JSONObject jsonObj1 = new JSONObject(jsonObj.getString("Message"));

		JSONObject jsonOb = jsonObj1.getJSONArray("Records").getJSONObject(0);

		int size = jsonOb.getJSONObject("s3").getJSONObject("object").getInt("size");
		int pathSize = 0;
		if (size > 0) {
			String[] pathArray = jsonOb.getJSONObject("s3").getJSONObject("object").getString("key").split("/");
			pathSize = pathArray.length;

			return pathArray[pathSize - 1].toString();
		}
		return null;

	}
	
	/**
	 * For Non Ecomm object
	 * 
	 * @param textMessage
	 * @return The fileName from json object generated by Amazon AWS
	 * @throws JMSException
	 * @throws JSONException
	 */
	public static String getFileName(TextMessage textMessage) throws JMSException, JSONException {

		String text = textMessage.getText();
		JSONObject jsonObj = new JSONObject(text);

		if (!jsonObj.isNull("Records")) {
			jsonObj = jsonObj.getJSONArray("Records").getJSONObject(0);
			int size = jsonObj.getJSONObject("s3").getJSONObject("object").getInt("size");
			/*if (size == 0) {
				return null;
			}*/
			String[] pathArray = jsonObj.getJSONObject("s3").getJSONObject("object").getString("key").split("/");
			int pathSize = pathArray.length;
			String fileName = pathArray[pathSize - 1].toString();
			return fileName;
		}
		return null;
	}
	public static boolean isNumeric(String text) {
		return text.matches(REGEX_NUMERIC_PATTER);
	}

}

